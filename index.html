<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pulse Runner - Rhythm Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;500&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: #0f172a;
            overflow: hidden;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* Main Menu */
        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 2rem;
            z-index: 20;
            transition: opacity 0.5s ease, visibility 0.5s ease, background 0.5s ease;
            overflow-y: auto;
        }

        #mainMenu.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* Difficulty-based background colors */
        #mainMenu[data-difficulty="easy"] {
            background: linear-gradient(135deg, rgba(20, 40, 30, 0.98) 0%, rgba(34, 197, 94, 0.1) 100%);
        }
        
        #mainMenu[data-difficulty="medium"] {
            background: linear-gradient(135deg, rgba(40, 35, 20, 0.98) 0%, rgba(250, 204, 21, 0.1) 100%);
        }
        
        #mainMenu[data-difficulty="hard"] {
            background: linear-gradient(135deg, rgba(40, 25, 20, 0.98) 0%, rgba(249, 115, 22, 0.1) 100%);
        }
        
        #mainMenu[data-difficulty="pro"] {
            background: linear-gradient(135deg, rgba(40, 20, 20, 0.98) 0%, rgba(239, 68, 68, 0.15) 100%);
        }
        
        /* Difficulty-based font colors */
        #mainMenu[data-difficulty="easy"] .menu-title,
        #mainMenu[data-difficulty="easy"] .menu-section-title,
        #mainMenu[data-difficulty="easy"] .volume-icon,
        #mainMenu[data-difficulty="easy"] .volume-value {
            color: #22c55e;
            text-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
        }
        
        #mainMenu[data-difficulty="medium"] .menu-title,
        #mainMenu[data-difficulty="medium"] .menu-section-title,
        #mainMenu[data-difficulty="medium"] .volume-icon,
        #mainMenu[data-difficulty="medium"] .volume-value {
            color: #facc15;
            text-shadow: 0 0 15px rgba(250, 204, 21, 0.5);
        }
        
        #mainMenu[data-difficulty="hard"] .menu-title,
        #mainMenu[data-difficulty="hard"] .menu-section-title,
        #mainMenu[data-difficulty="hard"] .volume-icon,
        #mainMenu[data-difficulty="hard"] .volume-value {
            color: #f97316;
            text-shadow: 0 0 15px rgba(249, 115, 22, 0.5);
        }
        
        #mainMenu[data-difficulty="pro"] .menu-title,
        #mainMenu[data-difficulty="pro"] .menu-section-title,
        #mainMenu[data-difficulty="pro"] .volume-icon,
        #mainMenu[data-difficulty="pro"] .volume-value {
            color: #ef4444;
            text-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
        }

        .menu-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 900;
            color: #38bdf8;
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.8), 0 0 40px rgba(56, 189, 248, 0.4);
            margin-bottom: 0.25rem;
            letter-spacing: 3px;
        }

        .menu-subtitle {
            font-size: 1rem;
            color: #94a3b8;
            margin-bottom: 1.5rem;
            letter-spacing: 2px;
        }

        .menu-section {
            background: rgba(30, 41, 59, 0.8);
            padding: 1.25rem 2rem;
            border-radius: 12px;
            border: 1px solid rgba(56, 189, 248, 0.2);
            margin-bottom: 1rem;
            backdrop-filter: blur(10px);
            min-width: 320px;
            max-width: 420px;
            width: 90%;
        }

        .menu-section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: #38bdf8;
            margin-bottom: 1rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* Difficulty Selector */
        .difficulty-selector {
            display: flex;
            gap: 0.5rem;
        }

        .difficulty-btn {
            flex: 1;
            padding: 0.75rem 0.75rem;
            border: 2px solid #334155;
            background: transparent;
            color: #94a3b8;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .difficulty-btn:hover {
            border-color: #38bdf8;
            color: #38bdf8;
        }

        .difficulty-btn.active {
            border-color: #38bdf8;
            background: rgba(56, 189, 248, 0.2);
            color: #38bdf8;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }

        .difficulty-btn[data-difficulty="easy"].active {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.3);
        }

        .difficulty-btn[data-difficulty="medium"].active {
            border-color: #facc15;
            background: rgba(250, 204, 21, 0.2);
            color: #facc15;
            box-shadow: 0 0 15px rgba(250, 204, 21, 0.3);
        }

        .difficulty-btn[data-difficulty="hard"].active {
            border-color: #f97316;
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
            box-shadow: 0 0 15px rgba(249, 115, 22, 0.3);
        }

        .difficulty-btn[data-difficulty="pro"].active {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.3);
        }

        /* Volume Slider */
        .volume-control {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .volume-icon {
            color: #38bdf8;
            font-size: 1.2rem;
        }

        .volume-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #38bdf8;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
            transition: transform 0.2s ease;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        /* Difficulty-based volume slider colors */
        #mainMenu[data-difficulty="easy"] .volume-slider::-webkit-slider-thumb {
            background: #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);
        }
        
        #mainMenu[data-difficulty="medium"] .volume-slider::-webkit-slider-thumb {
            background: #facc15;
            box-shadow: 0 0 10px rgba(250, 204, 21, 0.6);
        }
        
        #mainMenu[data-difficulty="hard"] .volume-slider::-webkit-slider-thumb {
            background: #f97316;
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.6);
        }
        
        #mainMenu[data-difficulty="pro"] .volume-slider::-webkit-slider-thumb {
            background: #ef4444;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);
        }
        
        #mainMenu[data-difficulty="easy"] .volume-slider {
            background: rgba(34, 197, 94, 0.5);
        }
        
        #mainMenu[data-difficulty="medium"] .volume-slider {
            background: rgba(250, 204, 21, 0.5);
        }
        
        #mainMenu[data-difficulty="hard"] .volume-slider {
            background: rgba(249, 115, 22, 0.5);
        }
        
        #mainMenu[data-difficulty="pro"] .volume-slider {
            background: rgba(239, 68, 68, 0.5);
        }

        .volume-value {
            font-family: 'Orbitron', sans-serif;
            color: #38bdf8;
            min-width: 45px;
            text-align: right;
        }

        /* File Input */
        .file-input-wrapper {
            position: relative;
            margin-top: 1rem;
        }

        .file-input {
            display: none;
        }

        .file-btn {
            width: 100%;
            padding: 1rem 2rem;
            border: 2px solid #38bdf8;
            background: transparent;
            color: #38bdf8;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            letter-spacing: 2px;
        }

        .file-btn:hover {
            background: rgba(56, 189, 248, 0.2);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.4);
        }

        .file-btn.loaded {
            border-color: #94a3b8;
            color: #94a3b8;
        }
        
        /* Difficulty-based file button colors */
        #mainMenu[data-difficulty="easy"] .file-btn {
            border-color: #22c55e;
            color: #22c55e;
        }
        
        #mainMenu[data-difficulty="easy"] .file-btn:hover {
            background: rgba(34, 197, 94, 0.2);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
        }
        
        #mainMenu[data-difficulty="medium"] .file-btn {
            border-color: #facc15;
            color: #facc15;
        }
        
        #mainMenu[data-difficulty="medium"] .file-btn:hover {
            background: rgba(250, 204, 21, 0.2);
            box-shadow: 0 0 20px rgba(250, 204, 21, 0.4);
        }
        
        #mainMenu[data-difficulty="hard"] .file-btn {
            border-color: #f97316;
            color: #f97316;
        }
        
        #mainMenu[data-difficulty="hard"] .file-btn:hover {
            background: rgba(249, 115, 22, 0.2);
            box-shadow: 0 0 20px rgba(249, 115, 22, 0.4);
        }
        
        #mainMenu[data-difficulty="pro"] .file-btn {
            border-color: #ef4444;
            color: #ef4444;
        }
        
        #mainMenu[data-difficulty="pro"] .file-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
        }

        .song-info {
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: #94a3b8;
            text-align: center;
            display: none;
        }

        .song-info.visible {
            display: block;
        }
        
        /* Difficulty-based song-info colors */
        #mainMenu[data-difficulty="easy"] .song-info {
            color: #22c55e;
        }
        
        #mainMenu[data-difficulty="medium"] .song-info {
            color: #facc15;
        }
        
        #mainMenu[data-difficulty="hard"] .song-info {
            color: #f97316;
        }
        
        #mainMenu[data-difficulty="pro"] .song-info {
            color: #ef4444;
        }

        /* Start Button Container */
        .start-btn-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 1rem 0 2rem 0;
            padding-bottom: 1rem;
        }

        #startBtn {
            display: none;
            padding: 0.875rem 2.5rem;
            border: none;
            background: linear-gradient(135deg, #38bdf8 0%, #0ea5e9 100%);
            color: #0f172a;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            border-radius: 50px;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.5);
        }

        #startBtn.visible {
            display: block;
        }

        #startBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px rgba(56, 189, 248, 0.7);
        }

        /* Scanning Overlay */
        #scanningOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 25;
        }

        #scanningOverlay.visible {
            display: flex;
        }

        .scanning-text {
            font-family: 'Orbitron', sans-serif;
            color: #38bdf8;
            font-size: 1.5rem;
            margin-top: 2rem;
            letter-spacing: 2px;
        }

        .scanning-bar {
            width: 300px;
            height: 4px;
            background: #334155;
            border-radius: 2px;
            margin-top: 1rem;
            overflow: hidden;
        }

        .scanning-progress {
            height: 100%;
            background: linear-gradient(90deg, #38bdf8, #0ea5e9);
            width: 0%;
            transition: width 0.1s ease;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem 2rem;
            display: none;
            z-index: 15;
        }

        #hud.visible {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* HUD Difficulty-based colors */
        body[data-difficulty="easy"] #hud .stat-value,
        body[data-difficulty="easy"] #hud .health-segment:not(.lost) {
            color: #22c55e;
            background: rgba(34, 197, 94, 0.5);
            text-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        
        body[data-difficulty="medium"] #hud .stat-value,
        body[data-difficulty="medium"] #hud .health-segment:not(.lost) {
            color: #facc15;
            background: rgba(250, 204, 21, 0.5);
            text-shadow: 0 0 10px rgba(250, 204, 21, 0.5);
        }
        
        body[data-difficulty="hard"] #hud .stat-value,
        body[data-difficulty="hard"] #hud .health-segment:not(.lost) {
            color: #f97316;
            background: rgba(249, 115, 22, 0.5);
            text-shadow: 0 0 10px rgba(249, 115, 22, 0.5);
        }
        
        body[data-difficulty="pro"] #hud .stat-value,
        body[data-difficulty="pro"] #hud .health-segment:not(.lost) {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.5);
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        /* Progress Bar */
        .progress-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: #1e293b;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            transition: width 0.1s linear;
        }
        
        /* Difficulty-based progress bar colors */
        body[data-difficulty="easy"] .progress-bar {
            background: linear-gradient(90deg, #22c55e, #4ade80);
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        
        body[data-difficulty="medium"] .progress-bar {
            background: linear-gradient(90deg, #facc15, #fde047);
            box-shadow: 0 0 10px rgba(250, 204, 21, 0.5);
        }
        
        body[data-difficulty="hard"] .progress-bar {
            background: linear-gradient(90deg, #f97316, #fb923c);
            box-shadow: 0 0 10px rgba(249, 115, 22, 0.5);
        }
        
        body[data-difficulty="pro"] .progress-bar {
            background: linear-gradient(90deg, #ef4444, #f87171);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        /* Health Bar */
        .health-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .health-icon {
            font-size: 1.5rem;
        }

        .health-bar {
            display: flex;
            gap: 4px;
        }

        .health-segment {
            width: 25px;
            height: 8px;
            background: #22c55e;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .health-segment.lost {
            background: #334155;
        }

        /* Stats */
        .stats-display {
            display: flex;
            gap: 2rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: #38bdf8;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Pause Menu */
        #pauseMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(15, 23, 42, 0.98);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #pauseMenu.visible {
            display: flex;
        }

        .pause-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: #38bdf8;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
        }

        .pause-section {
            background: rgba(30, 41, 59, 0.8);
            padding: 1.5rem 2rem;
            border-radius: 12px;
            margin-bottom: 1.5rem;
            min-width: 300px;
        }

        /* End Screen */
        #endScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.98);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 35;
        }

        #endScreen.visible {
            display: flex;
        }

        .end-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5rem;
            margin-bottom: 2rem;
            text-shadow: 0 0 30px currentColor;
        }

        .end-title.victory {
            color: #22c55e;
        }

        .end-title.defeat {
            color: #ef4444;
        }
        
        /* End screen difficulty-based colors */
        body[data-difficulty="easy"] .end-title.victory,
        body[data-difficulty="easy"] .end-stat-value {
            color: #22c55e;
            text-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
        }
        
        body[data-difficulty="medium"] .end-title.victory,
        body[data-difficulty="medium"] .end-stat-value {
            color: #facc15;
            text-shadow: 0 0 20px rgba(250, 204, 21, 0.6);
        }
        
        body[data-difficulty="hard"] .end-title.victory,
        body[data-difficulty="hard"] .end-stat-value {
            color: #f97316;
            text-shadow: 0 0 20px rgba(249, 115, 22, 0.6);
        }
        
        body[data-difficulty="pro"] .end-title.victory,
        body[data-difficulty="pro"] .end-stat-value {
            color: #ef4444;
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.6);
        }
        
        body[data-difficulty="easy"] .end-stat {
            border-color: rgba(34, 197, 94, 0.3);
            background: rgba(34, 197, 94, 0.1);
        }
        
        body[data-difficulty="medium"] .end-stat {
            border-color: rgba(250, 204, 21, 0.3);
            background: rgba(250, 204, 21, 0.1);
        }
        
        body[data-difficulty="hard"] .end-stat {
            border-color: rgba(249, 115, 22, 0.3);
            background: rgba(249, 115, 22, 0.1);
        }
        
        body[data-difficulty="pro"] .end-stat {
            border-color: rgba(239, 68, 68, 0.3);
            background: rgba(239, 68, 68, 0.1);
        }

        .end-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .end-stat {
            text-align: center;
            padding: 1.5rem;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(56, 189, 248, 0.2);
        }

        .end-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            color: #38bdf8;
        }

        .end-stat-label {
            font-size: 0.8rem;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 0.5rem;
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            display: none;
            z-index: 25;
            padding: 1rem;
        }

        @media (max-width: 768px) {
            #mobileControls.visible {
                display: flex;
                justify-content: space-between;
                align-items: flex-end;
            }
        }

        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 4px;
        }

        .d-pad-btn {
            background: rgba(56, 189, 248, 0.3);
            border: 2px solid rgba(56, 189, 248, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #38bdf8;
            touch-action: manipulation;
            cursor: pointer;
        }

        .d-pad-btn:active {
            background: rgba(56, 189, 248, 0.6);
        }

        .d-pad-btn.up { grid-column: 2; }
        .d-pad-btn.left { grid-column: 1; grid-row: 2; }
        .d-pad-btn.center { grid-column: 2; grid-row: 2; background: transparent; border: none; }
        .d-pad-btn.right { grid-column: 3; grid-row: 2; }
        .d-pad-btn.down { grid-column: 2; grid-row: 3; }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .action-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid rgba(56, 189, 248, 0.6);
            background: rgba(56, 189, 248, 0.2);
            color: #38bdf8;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            touch-action: manipulation;
        }

        .action-btn:active {
            background: rgba(56, 189, 248, 0.4);
            transform: scale(0.95);
        }

        .btn {
            padding: 1rem 2rem;
            border: none;
            background: linear-gradient(135deg, #38bdf8 0%, #0ea5e9 100%);
            color: #0f172a;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            letter-spacing: 2px;
            min-width: 200px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
        }

        .btn.secondary {
            background: transparent;
            border: 2px solid #38bdf8;
            color: #38bdf8;
        }

        .btn.secondary:hover {
            background: rgba(56, 189, 248, 0.2);
        }

        .btn-group {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        @media (max-width: 768px) {
            .menu-title {
                font-size: 2.5rem;
            }

            .menu-section {
                min-width: 280px;
                padding: 1.5rem;
            }

            .difficulty-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.65rem;
            }

            .end-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .end-stat-value {
                font-size: 1.8rem;
            }
        }

        .start-btn-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 1rem 0 1rem 0;
            padding-bottom: 0.5rem;
        }

        #startBtn {
            display: none;
            padding: 0.875rem 2.5rem;
            border: none;
            background: linear-gradient(135deg, #38bdf8 0%, #0ea5e9 100%);
            color: #0f172a;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            border-radius: 50px;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.5);
        }
        
        #startBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(56, 189, 248, 0.7);
        }
        
        /* Difficulty-based START button colors */
        #mainMenu[data-difficulty="easy"] #startBtn {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            box-shadow: 0 0 25px rgba(34, 197, 94, 0.6);
        }
        
        #mainMenu[data-difficulty="medium"] #startBtn {
            background: linear-gradient(135deg, #facc15 0%, #eab308 100%);
            box-shadow: 0 0 25px rgba(250, 204, 21, 0.6);
        }
        
        #mainMenu[data-difficulty="hard"] #startBtn {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            box-shadow: 0 0 25px rgba(249, 115, 22, 0.6);
        }
        
        #mainMenu[data-difficulty="pro"] #startBtn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.6);
        }

        /*ÊèêÁ§∫ÊñáÂ≠ó*/
        .controls-hint {
            margin-top: 1.5rem;
            color: #64748b;
            font-size: 0.75rem;
            text-align: center;
            letter-spacing: 1px;
        }
        
        /* Difficulty-based hint colors */
        #mainMenu[data-difficulty="easy"] .controls-hint {
            color: rgba(34, 197, 94, 0.7);
        }
        
        #mainMenu[data-difficulty="medium"] .controls-hint {
            color: rgba(250, 204, 21, 0.7);
        }
        
        #mainMenu[data-difficulty="hard"] .controls-hint {
            color: rgba(249, 115, 22, 0.7);
        }
        
        #mainMenu[data-difficulty="pro"] .controls-hint {
            color: rgba(239, 68, 68, 0.7);
        }

        @media (max-width: 768px) {
            .controls-hint {
                display: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Main Menu -->
    <div id="mainMenu">
        <h1 class="menu-title">PULSE RUNNER</h1>
        <p class="menu-subtitle">RHYTHM ACTION GAME</p>

        <div class="menu-section">
            <div class="menu-section-title">1. Difficulty</div>
            <div class="difficulty-selector">
                <button class="difficulty-btn" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
                <button class="difficulty-btn" data-difficulty="pro">Pro Gamer</button>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-section-title">2. Volume</div>
            <div class="volume-control">
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="70">
                <span class="volume-value" id="volumeValue">70%</span>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-section-title">3. Audio</div>
            <div class="file-input-wrapper">
                <input type="file" id="audioFile" class="file-input" accept="audio/*">
                <button class="file-btn" id="fileBtn">Select Song</button>
                <p class="song-info" id="songInfo"></p>
            </div>
        </div>

        <div class="start-btn-container">
            <button class="btn" id="startBtn">START</button>
        </div>

        <p class="controls-hint">Use WASD or Arrow Keys to move | Space to Dash | ESC to Pause</p>
    </div>

    <!-- Scanning Overlay -->
    <div id="scanningOverlay">
        <div style="font-family: 'Orbitron', sans-serif; font-size: 2rem; color: #38bdf8;">ANALYZING AUDIO</div>
        <div class="scanning-text" id="scanStatus">Detecting beats...</div>
        <div class="scanning-bar">
            <div class="scanning-progress" id="scanProgress"></div>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="health-container">
            <div class="health-bar" id="healthBar"></div>
        </div>
        <div class="stats-display">
            <div class="stat-item">
                <div class="stat-value" id="scoreValue">0</div>
                <div class="stat-label">Score</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="comboValue">0</div>
                <div class="stat-label">Combo</div>
            </div>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div class="d-pad">
            <button class="d-pad-btn up" data-dir="up">‚ñ≤</button>
            <button class="d-pad-btn left" data-dir="left">‚óÄ</button>
            <button class="d-pad-btn center"></button>
            <button class="d-pad-btn right" data-dir="right">‚ñ∂</button>
            <button class="d-pad-btn down" data-dir="down">‚ñº</button>
        </div>
        <div class="action-buttons">
            <button class="action-btn" id="dashBtn">DASH</button>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <h2 class="pause-title">PAUSED</h2>
        <div class="pause-section">
            <div class="menu-section-title">Volume</div>
            <div class="volume-control">
                <span class="volume-icon">üîä</span>
                <input type="range" class="volume-slider" id="pauseVolumeSlider" min="0" max="100" value="70">
                <span class="volume-value" id="pauseVolumeValue">70%</span>
            </div>
        </div>
        <div class="btn-group">
            <button class="btn secondary" id="resumeBtn">Resume</button>
            <button class="btn secondary" id="quitBtn">Quit to Menu</button>
        </div>
    </div>

    <!-- End Screen -->
    <div id="endScreen">
        <h2 class="end-title" id="endTitle">SONG COMPLETED</h2>
        <div class="end-stats">
            <div class="end-stat">
                <div class="end-stat-value" id="finalDodged">0</div>
                <div class="end-stat-label">Obstacles Dodged</div>
            </div>
            <div class="end-stat">
                <div class="end-stat-value" id="finalTime">0:00</div>
                <div class="end-stat-label">Time Survived</div>
            </div>
            <div class="end-stat">
                <div class="end-stat-value" id="finalHit">0</div>
                <div class="end-stat-label">Obstacles Hit</div>
            </div>
        </div>
        <div class="btn-group">
            <button class="btn" id="retryBtn">Retry</button>
            <button class="btn secondary" id="menuBtn">Main Menu</button>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const DIFFICULTY_COLORS = {
            easy: {
                player: '#22c55e',
                playerDash: '#4ade80',
                obstacle: '#4ade80',
                laserWarning: 'rgba(34, 197, 94, 0.4)',
                laserActive: '#22c55e',
                background: '#0a1a12',
                grid: '#14532d'
            },
            medium: {
                player: '#facc15',
                playerDash: '#fde047',
                obstacle: '#fde047',
                laserWarning: 'rgba(250, 204, 21, 0.4)',
                laserActive: '#facc15',
                background: '#1a140a',
                grid: '#45320a'
            },
            hard: {
                player: '#f97316',
                playerDash: '#fb923c',
                obstacle: '#fb923c',
                laserWarning: 'rgba(249, 115, 22, 0.4)',
                laserActive: '#f97316',
                background: '#1a0f0a',
                grid: '#4a1d0a'
            },
            pro: {
                player: '#ef4444',
                playerDash: '#f87171',
                obstacle: '#f87171',
                laserWarning: 'rgba(239, 68, 68, 0.4)',
                laserActive: '#ef4444',
                background: '#1a0a0a',
                grid: '#4a0a0a'
            }
        };
        
        const CONFIG = {
            difficulties: {
                easy: {
                    name: 'Easy',
                    speedMultiplier: 1.0,
                    maxHealth: 6,
                    warningTime: 2000,
                    laserDuration: 300,
                    beatSensitivity: 1.0
                },
                medium: {
                    name: 'Medium',
                    speedMultiplier: 1.3,
                    maxHealth: 5,
                    warningTime: 1500,
                    laserDuration: 400,
                    beatSensitivity: 0.65
                },
                hard: {
                    name: 'Hard',
                    speedMultiplier: 1.6,
                    maxHealth: 4,
                    warningTime: 1000,
                    laserDuration: 600,
                    beatSensitivity: 0.25
                },
                pro: {
                    name: 'Pro Gamer',
                    speedMultiplier: 2.0,
                    maxHealth: 2,
                    warningTime: 600,
                    laserDuration: 800,
                    beatSensitivity: 0.15
                }
            },
            player: {
                size: 30,
                speed: 8,
                dashSpeed: 15,
                dashDuration: 100,
                dashCooldown: 1000,
                invulnerabilityTime: 500
            },
            grid: {
                cellSize: 50,
                scrollSpeed: 2
            },
            colors: {
                player: '#38bdf8',
                playerDash: '#ffffff',
                obstacle: '#f472b6',
                laserWarning: 'rgba(250, 204, 21, 0.4)',
                laserActive: '#ef4444',
                background: '#0f172a',
                grid: '#1e293b'
            }
        };

        // ==================== GAME STATE ====================
        const gameState = {
            menu: true,
            playing: false,
            paused: false,
            ended: false,
            difficulty: 'none',
            volume: 0.7,
            audioContext: null,
            audioBuffer: null,
            audioSource: null,
            gainNode: null,
            analyser: null,
            beats: [],
            currentBeatIndex: 0,
            startTime: 0,
            pausedTime: 0,
            elapsedTime: 0,
            player: null,
            obstacles: [],
            score: 0,
            combo: 0,
            maxCombo: 0,
            obstaclesDodged: 0,
            obstaclesHit: 0,
            lastDashTime: 0,
            isDashing: false,
            dashEndTime: 0,
            lastHitTime: 0
        };

        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ==================== PLAYER CLASS ====================
        class Player {
            constructor() {
                this.x = 150;
                this.y = canvas.height / 2;
                this.size = CONFIG.player.size;
                this.speed = CONFIG.player.speed;
                this.health = CONFIG.difficulties[gameState.difficulty].maxHealth;
                this.maxHealth = this.health;
                this.targetX = 150;
                this.targetY = canvas.height / 2;
            }

            update(deltaTime) {
                // Handle dashing movement (velocity-based)
                if (gameState.isDashing) {
                    this.x += this.dashVelX;
                    this.y += this.dashVelY;
                    this.targetX = this.x
                    this.targetY = this.y
                } else {
                    // Normal movement with smoothing - more responsive
                    const smoothing = 0.3;
                    this.x += (this.targetX - this.x) * smoothing;
                    this.y += (this.targetY - this.y) * smoothing;
                }

                // Boundary check
                const margin = this.size / 2;
                this.x = Math.max(margin, Math.min(canvas.width - margin, this.x));
                this.y = Math.max(margin, Math.min(canvas.height - margin, this.y));

                this.targetX = Math.max(margin, Math.min(canvas.width - margin, this.targetX));
                this.targetY = Math.max(margin, Math.min(canvas.height - margin, this.targetY));

                // Update dashing state
                if (gameState.isDashing && Date.now() > gameState.dashEndTime) {
                    gameState.isDashing = false;
                    this.dashVelX = 0;
                    this.dashVelY = 0;
                }
            }

            draw() {
                ctx.save();

                const centerX = this.x;
                const centerY = this.y;
                const size = this.size;

                // Glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = gameState.isDashing ? CONFIG.colors.playerDash : CONFIG.colors.player;

                // Main body
                ctx.fillStyle = gameState.isDashing ? CONFIG.colors.playerDash : CONFIG.colors.player;
                ctx.beginPath();
                
                // Triangular ship shape
                ctx.moveTo(centerX + size, centerY);
                ctx.lineTo(centerX - size / 2, centerY - size / 2);
                ctx.lineTo(centerX - size / 3, centerY);
                ctx.lineTo(centerX - size / 2, centerY + size / 2);
                ctx.closePath();
                ctx.fill();

                // Engine glow
                if (!gameState.isDashing) {
                    ctx.fillStyle = CONFIG.colors.player + '80';
                    ctx.beginPath();
                    ctx.moveTo(centerX - size / 2, centerY - size / 4);
                    ctx.lineTo(centerX - size - Math.random() * 10, centerY);
                    ctx.lineTo(centerX - size / 2, centerY + size / 4);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }

            move(direction) {
                const moveAmount = CONFIG.player.speed * 2;
                
                switch(direction) {
                    case 'up':
                        this.targetY -= moveAmount;
                        break;
                    case 'down':
                        this.targetY += moveAmount;
                        break;
                    case 'left':
                        this.targetX -= moveAmount;
                        break;
                    case 'right':
                        this.targetX += moveAmount;
                        break;
                }
            }

            dash() {
                if (Date.now() - gameState.lastDashTime > CONFIG.player.dashCooldown && !gameState.isDashing) {
                    gameState.isDashing = true;
                    gameState.dashEndTime = Date.now() + CONFIG.player.dashDuration;
                    gameState.lastDashTime = Date.now();
                    
                    // Calculate dash direction based on current movement
                    const moveX = this.targetX - this.x;
                    const moveY = this.targetY - this.y;
                    const moveMag = Math.sqrt(moveX * moveX + moveY * moveY);
                    
                    const dashSpeed = CONFIG.player.dashSpeed * 3;
                    
                    if (moveMag > 5) {
                        // Dash in the direction the player is moving
                        this.dashVelX = (moveX / moveMag) * dashSpeed;
                        this.dashVelY = (moveY / moveMag) * dashSpeed;
                    } else {
                        // Default dash forward (right) if not moving
                        this.dashVelX = dashSpeed;
                        this.dashVelY = 0;
                    }
                }
            }

            takeDamage() {
                if (gameState.isDashing) return false;
                if (Date.now() - gameState.lastHitTime < CONFIG.player.invulnerabilityTime) return false;

                this.health--;
                gameState.lastHitTime = Date.now();
                gameState.obstaclesHit++;
                gameState.combo = 0;
                updateHealthBar();
                updateHUD();
                
                // Screen shake effect
                shakeScreen();
                
                return this.health <= 0;
            }
        }

        // ==================== OBSTACLE CLASSES ====================
        class Obstacle {
            constructor(beatTime, type) {
                this.beatTime = beatTime;
                this.type = type;
                this.spawnTime = Date.now();
                this.remove = false;
                
                const difficulty = CONFIG.difficulties[gameState.difficulty];
                const baseSpeed = 500; // pixels per second
                this.speed = baseSpeed * difficulty.speedMultiplier;
                
                if (type === 'square') {
                    this.width = 40;
                    this.height = 40;
                    this.y = Math.random() * (canvas.height - this.height);
                    this.x = canvas.width + this.width;
                    this.damage = 1;
                } else if (type === 'laser') {
                    // Determine if horizontal or vertical laser
                    this.xAxis = Math.random() > 0.5;
                    
                    if (this.xAxis) {
                        // Horizontal laser - spans full width, positioned at Y
                        this.y = Math.random() * (canvas.height - 60) + 30;
                        this.x = 0;
                        this.width = canvas.width;
                        this.height = 10;
                    } else {
                        // Vertical laser - spans full height, positioned at X
                        this.x = Math.random() * (canvas.width - 60) + 30;
                        this.y = 0;
                        this.width = 10;
                        this.height = canvas.height;
                    }

                    this.warningEndTime = Date.now() + difficulty.warningTime;
                    this.activeEndTime = this.warningEndTime + difficulty.laserDuration;
                    this.damage = 1;
                    this.isWarning = true;
                }
            }

            update() {
                if (this.type === 'square') {
                    this.x -= this.speed * (1/60); // Approximate for 60fps
                    
                    if (this.x + this.width < 0) {
                        this.remove = true;
                        gameState.obstaclesDodged++;
                        gameState.score += 10 * (1 + Math.floor(gameState.combo / 10));
                        gameState.combo++;
                        updateHUD();
                    }
                } else if (this.type === 'laser') {
                    const now = Date.now();
                    if (now >= this.warningEndTime && this.isWarning) {
                        this.isWarning = false;
                    }
                    if (!this.isWarning && now >= this.activeEndTime) {
                        this.remove = true;
                        gameState.obstaclesDodged++;
                        gameState.score += 20 * (1 + Math.floor(gameState.combo / 10));
                        gameState.combo++;
                        updateHUD();
                    }
                }
            }

            draw() {
                if (this.type === 'square') {
                    ctx.save();
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = CONFIG.colors.obstacle;
                    ctx.fillStyle = CONFIG.colors.obstacle;
                    ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                    ctx.restore();
                } else if (this.type === 'laser') {
                    ctx.save();
                    
                    if (this.isWarning) {
                        ctx.strokeStyle = CONFIG.colors.laserWarning;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([10, 10]);
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = CONFIG.colors.laserWarning;
                        
                        if (this.xAxis) {
                            // Horizontal laser warning
                            const laserTop = this.y - this.height / 2;
                            ctx.beginPath();
                            ctx.moveTo(0, laserTop);
                            ctx.lineTo(canvas.width, laserTop);
                            ctx.stroke();
                        } else {
                            // Vertical laser warning
                            const laserLeft = this.x - this.width / 2;
                            ctx.beginPath();
                            ctx.moveTo(laserLeft, 0);
                            ctx.lineTo(laserLeft, canvas.height);
                            ctx.stroke();
                        }
                    } else {
                        ctx.fillStyle = CONFIG.colors.laserActive;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = CONFIG.colors.laserActive;
                        
                        if (this.xAxis) {
                            // Horizontal laser
                            const laserTop = this.y - this.height / 2;
                            ctx.fillRect(0, laserTop, this.width, this.height);
                        } else {
                            // Vertical laser
                            const laserLeft = this.x - this.width / 2;
                            ctx.fillRect(laserLeft, 0, this.width, this.height);
                        }
                    }
                    ctx.restore();
                }
            }

            checkCollision(player) {
                const px = player.x;
                const py = player.y;
                const ps = player.size * 0.8; // Hitbox slightly smaller than visual

                if (this.type === 'square') {
                    return (
                        px + ps > this.x - this.width/2 &&
                        px - ps < this.x + this.width/2 &&
                        py + ps > this.y - this.height/2 &&
                        py - ps < this.y + this.height/2
                    );
                } else if (this.type === 'laser' && !this.isWarning) {
                    if (this.xAxis) {
                        // Horizontal laser collision
                        const laserTop = this.y - this.height/2;
                        const laserBottom = this.y + this.height/2;
                        return (
                            py + ps > laserTop &&
                            py - ps < laserBottom
                        );
                    } else {
                        // Vertical laser collision
                        const laserLeft = this.x - this.width/2;
                        const laserRight = this.x + this.width/2;
                        return (
                            px + ps > laserLeft &&
                            px - ps < laserRight
                        );
                    }
                }
                return false;
            }
        }

        // ==================== AUDIO PROCESSING ====================
        async function loadAudio(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        gameState.audioBuffer = await gameState.audioContext.decodeAudioData(arrayBuffer);
                        resolve(gameState.audioBuffer);
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function detectBeats(audioBuffer) {
            const channelData = audioBuffer.getChannelData(0);
            const sampleRate = audioBuffer.sampleRate;
            
            const beats = [];
            const sensitivity = CONFIG.difficulties[gameState.difficulty].beatSensitivity;
            const threshold = 0.35 * sensitivity; // Higher threshold = less sensitive
            const minInterval = 0.35; // Minimum 350ms between beats
            
            let lastBeatTime = 0;
            
            // Analyze in chunks for performance
            const chunkSize = 512;
            
            for (let i = 0; i < channelData.length - chunkSize; i += chunkSize) {
                // Calculate RMS energy for current chunk
                let energy = 0;
                for (let j = 0; j < chunkSize; j++) {
                    const sample = channelData[i + j];
                    energy += sample * sample;
                }
                energy = Math.sqrt(energy / chunkSize);
                
                const time = i / sampleRate;
                
                // Simple peak detection: energy higher than neighbors
                if (energy > threshold) {
                    // Check if this is a local maximum
                    let prevEnergy = 0, nextEnergy = 0;
                    
                    // Previous chunk
                    if (i > 0) {
                        for (let j = 0; j < chunkSize; j++) {
                            prevEnergy += channelData[i - chunkSize + j] * channelData[i - chunkSize + j];
                        }
                        prevEnergy = Math.sqrt(prevEnergy / chunkSize);
                    }
                    
                    // Next chunk
                    if (i + chunkSize < channelData.length) {
                        for (let j = 0; j < chunkSize; j++) {
                            nextEnergy += channelData[i + chunkSize + j] * channelData[i + chunkSize + j];
                        }
                        nextEnergy = Math.sqrt(nextEnergy / chunkSize);
                    }
                    
                    // Check if current is peak (must be significantly higher)
                    const peakThreshold = threshold * 1.2;
                    if (energy >= prevEnergy * 1.1 && energy > nextEnergy * 1.1 && energy > peakThreshold) {
                        if (time - lastBeatTime >= minInterval) {
                            // Determine beat type based on energy
                            let beatType = 'square';
                            const energyRatio = energy / threshold;
                            
                            if (energyRatio > 4) {
                                beatType = Math.random() > 0.3 ? 'laser' : 'square';
                            } else if (energyRatio > 2.5) {
                                beatType = Math.random() > 0.5 ? 'laser' : 'square';
                            } else if (energyRatio > 1.8) {
                                beatType = Math.random() > 0.7 ? 'laser' : 'square';
                            }
                            
                            // Limit lasers more strictly
                            const recentLasers = beats.filter(b => b.type === 'laser' && time - b.time < 4).length;
                            const recentBeats = beats.filter(b => time - b.time < 2).length;
                            if (beatType === 'laser' && (recentLasers >= 1 || recentBeats > 3)) {
                                beatType = 'square';
                            }
                            
                            beats.push({
                                time: time,
                                type: beatType,
                                spawned: false
                            });
                            lastBeatTime = time;
                        }
                    }
                }
            }
            
            // If no beats detected, generate rhythmic fallback beats
            if (beats.length < 3) {
                const duration = audioBuffer.duration;
                const bpm = 100; // Slower default BPM
                const beatInterval = 60 / bpm;
                
                for (let t = 2; t < duration - 2; t += beatInterval) {
                    if (t - lastBeatTime >= minInterval) {
                        const beatType = Math.random() > 0.8 ? 'laser' : 'square';
                        beats.push({
                            time: t,
                            type: beatType,
                            spawned: false
                        });
                        lastBeatTime = t;
                    }
                }
            }
            
            // Sort by time
            beats.sort((a, b) => a.time - b.time);
            
            return beats;
        }

        // ==================== SPAWN LOGIC ====================
        function calculateSpawnTime(beatTime) {
            const visualBuffer = 200; // Extra pixels for visual buffer
            const screenDistance = canvas.width - 150 + visualBuffer; // Player position to right edge + buffer
            const speed = CONFIG.difficulties[gameState.difficulty].speedMultiplier * 500;
            const travelTime = (screenDistance / speed) * 1000; // in milliseconds
            return (beatTime * 1000) - travelTime;
        }

        function spawnObstacles() {
            if (!gameState.playing || gameState.paused) return;
            
            const now = Date.now() - gameState.startTime;
            
            // Check all beats, not just from current index
            for (let i = 0; i < gameState.beats.length; i++) {
                const beat = gameState.beats[i];
                
                if (beat.spawned) continue;
                
                const spawnTime = calculateSpawnTime(beat.time);
                
                if (now >= spawnTime) {
                    beat.spawned = true;
                    
                    // Check if we should spawn based on difficulty and beat
                    let shouldSpawn = true;
                    
                    if (beat.type === 'laser') {
                        // Check if there's already an active laser
                        const hasActiveLaser = gameState.obstacles.some(o => o.type === 'laser' && !o.isWarning);
                        if (hasActiveLaser) shouldSpawn = false;
                    }
                    
                    if (shouldSpawn) {
                        gameState.obstacles.push(new Obstacle(beat.time, beat.type));
                    }
                }
            }
        }

        // ==================== INPUT HANDLING ====================
        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === 'Escape' && gameState.playing) {
                togglePause();
            }
            
            if (e.key === ' ' && gameState.playing && !gameState.paused) {
                e.preventDefault();
                gameState.player.dash();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function handleInput() {
            if (!gameState.playing || gameState.paused) return;
            
            const player = gameState.player;
            
            if (keys['w'] || keys['arrowup']) player.move('up');
            if (keys['s'] || keys['arrowdown']) player.move('down');
            if (keys['a'] || keys['arrowleft']) player.move('left');
            if (keys['d'] || keys['arrowright']) player.move('right');
        }

        // Mobile controls
        document.querySelectorAll('.d-pad-btn').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.playing && !gameState.paused) {
                    gameState.player.move(btn.dataset.dir);
                }
            });
        });

        document.getElementById('dashBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.playing && !gameState.paused) {
                gameState.player.dash();
            }
        });

        // Visibility change handler
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.playing && !gameState.paused) {
                togglePause();
            }
        });

        // ==================== UI FUNCTIONS ====================
        function showScanning(show) {
            document.getElementById('scanningOverlay').classList.toggle('visible', show);
        }

        function updateScanProgress(progress, status) {
            document.getElementById('scanProgress').style.width = progress + '%';
            document.getElementById('scanStatus').textContent = status;
        }

        function updateHealthBar() {
            const healthBar = document.getElementById('healthBar');
            healthBar.innerHTML = '';
            
            for (let i = 0; i < gameState.player.maxHealth; i++) {
                const segment = document.createElement('div');
                segment.className = 'health-segment' + (i >= gameState.player.health ? ' lost' : '');
                healthBar.appendChild(segment);
            }
        }

        function updateHUD() {
            document.getElementById('scoreValue').textContent = gameState.score;
            document.getElementById('comboValue').textContent = gameState.combo;
        }

        function updateProgressBar() {
            if (!gameState.audioBuffer) return;
            
            const duration = gameState.audioBuffer.duration;
            const elapsed = gameState.elapsedTime / 1000;
            const progress = (elapsed / duration) * 100;
            
            document.getElementById('progressBar').style.width = Math.min(100, progress) + '%';
        }

        function togglePause() {
            if (!gameState.playing) return;
            
            // Toggle paused state
            gameState.paused = !gameState.paused;
            
            // Update UI
            document.getElementById('pauseMenu').classList.toggle('visible', gameState.paused);
            
            if (gameState.paused) {
                // Record when we paused for accurate time tracking
                gameState.pauseStartTime = Date.now();
                
                // Pause audio using multiple methods for reliability
                if (gameState.audioSource && gameState.audioContext) {
                    try {
                        // Method 1: Suspend the audio context (most reliable)
                        if (gameState.audioContext.state === 'running') {
                            gameState.audioContext.suspend();
                        }
                    } catch (e) {
                        console.warn('Could not suspend audio context:', e);
                    }
                }
            } else {
                // Adjust start time to account for pause duration
                const pauseDuration = Date.now() - gameState.pauseStartTime;
                gameState.startTime += pauseDuration;
                
                // Resume audio
                if (gameState.audioSource && gameState.audioContext) {
                    try {
                        if (gameState.audioContext.state === 'suspended') {
                            gameState.audioContext.resume();
                        }
                    } catch (e) {
                        console.warn('Could not resume audio context:', e);
                    }
                }
            }
        }

        function endGame(victory) {
            gameState.playing = false;
            gameState.ended = true;
            
            if (gameState.audioSource) {
                gameState.audioSource.stop();
            }
            
            const endScreen = document.getElementById('endScreen');
            const endTitle = document.getElementById('endTitle');
            
            if (victory) {
                endTitle.textContent = 'SONG COMPLETED';
                endTitle.className = 'end-title victory';
            } else {
                endTitle.textContent = 'GAME OVER';
                endTitle.className = 'end-title defeat';
            }
            
            document.getElementById('finalDodged').textContent = gameState.obstaclesDodged;
            document.getElementById('finalTime').textContent = formatTime(gameState.elapsedTime / 1000);
            document.getElementById('finalHit').textContent = gameState.obstaclesHit;
            
            endScreen.classList.add('visible');
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        let shakeIntensity = 0;
        function shakeScreen() {
            shakeIntensity = 15;
        }

        // Helper function to update START button visibility
        function updateStartButtonVisibility() {
            const startBtn = document.getElementById('startBtn');
            // Show START button only when difficulty is selected AND song is loaded
            const songLoaded = document.getElementById('fileBtn').classList.contains('loaded');
            const difficultySelected = gameState.difficulty !== 'none';
            
            if (songLoaded && difficultySelected) {
                startBtn.classList.add('visible');
            } else {
                startBtn.classList.remove('visible');
            }
        }

        // ==================== MENU SETUP ====================
        function setupMenu() {
            // Difficulty buttons
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.difficulty = btn.dataset.difficulty;
                    
                    // Update menu background color
                    const mainMenu = document.getElementById('mainMenu');
                    if (gameState.difficulty === 'none') {
                        mainMenu.removeAttribute('data-difficulty');
                    } else {
                        mainMenu.setAttribute('data-difficulty', gameState.difficulty);
                    }
                    
                    // Update START button visibility
                    updateStartButtonVisibility();
                });
            });

            // Volume slider
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeValue = document.getElementById('volumeValue');
            
            volumeSlider.addEventListener('input', () => {
                gameState.volume = volumeSlider.value / 100;
                volumeValue.textContent = volumeSlider.value + '%';
                if (gameState.gainNode) {
                    gameState.gainNode.gain.value = gameState.volume;
                }
            });

            // Pause volume
            const pauseVolumeSlider = document.getElementById('pauseVolumeSlider');
            const pauseVolumeValue = document.getElementById('pauseVolumeValue');
            
            pauseVolumeSlider.addEventListener('input', () => {
                gameState.volume = pauseVolumeSlider.value / 100;
                pauseVolumeValue.textContent = pauseVolumeSlider.value + '%';
                if (gameState.gainNode) {
                    gameState.gainNode.gain.value = gameState.volume;
                }
            });

            // Audio file input
            const audioFile = document.getElementById('audioFile');
            const fileBtn = document.getElementById('fileBtn');
            const songInfo = document.getElementById('songInfo');
            
            fileBtn.addEventListener('click', () => {
                audioFile.value = null;
                audioFile.click();
            });
            
            audioFile.addEventListener("change", async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                fileBtn.textContent = 'Loading...';
                fileBtn.classList.add('loading');
                
                try {
                    if (!gameState.audioContext) {
                        gameState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    showScanning(true);
                    updateScanProgress(10, 'Loading audio file...');
                    
                    await loadAudio(file);
                    
                    updateScanProgress(30, 'Detecting beats...');
                    
                    // Small delay for UI update
                    await new Promise(r => setTimeout(r, 100));
                    
                    gameState.beats = detectBeats(gameState.audioBuffer);
                    
                    updateScanProgress(100, `Found ${gameState.beats.length} beats!`);
                    
                    await new Promise(r => setTimeout(r, 500));
                    
                    showScanning(false);
                    
                    const duration = gameState.audioBuffer.duration;
                    songInfo.textContent = `${file.name} - ${formatTime(duration)} - ${gameState.beats.length} beats detected`;
                    songInfo.classList.add('visible');
                    
                    fileBtn.textContent = 'Song Loaded';
                    fileBtn.classList.add('loaded');
                    
                    // Update START button visibility
                    updateStartButtonVisibility();
                    
                } catch (err) {
                    console.error('Error loading audio:', err);
                    fileBtn.textContent = 'Error loading file';
                    fileBtn.classList.remove('loaded');
                    showScanning(false);
                }
            });

            // Start button
            document.getElementById('startBtn').addEventListener('click', startGame);

            // Pause menu buttons
            document.getElementById('resumeBtn').addEventListener('click', togglePause);
            document.getElementById('quitBtn').addEventListener('click', () => {
                togglePause();
                returnToMenu();
            });

            // End screen buttons
            document.getElementById('retryBtn').addEventListener('click', () => {
                document.getElementById('endScreen').classList.remove('visible');
                startGame();
            });
            
            document.getElementById('menuBtn').addEventListener('click', () => {
                document.getElementById('endScreen').classList.remove('visible');
                returnToMenu();
            });
        }

        function startGame() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('hud').classList.add('visible');
            document.getElementById('mobileControls').classList.add('visible');
            
            // Set body difficulty attribute for CSS theming
            document.body.setAttribute('data-difficulty', gameState.difficulty);
            
            // Apply difficulty-specific colors to CONFIG
            const difficultyColors = DIFFICULTY_COLORS[gameState.difficulty];
            CONFIG.colors = { ...difficultyColors };
            
            // Reset game state
            gameState.playing = true;
            gameState.paused = false;
            gameState.ended = false;
            gameState.obstacles = [];
            gameState.score = 0;
            gameState.combo = 0;
            gameState.obstaclesDodged = 0;
            gameState.obstaclesHit = 0;
            gameState.currentBeatIndex = 0;
            gameState.isDashing = false;
            gameState.lastDashTime = 0;
            gameState.lastHitTime = 0;
            
            // Reset beat spawn status so obstacles load on retry
            if (gameState.beats) {
                gameState.beats.forEach(beat => {
                    beat.spawned = false;
                });
            }
            
            // Initialize player
            gameState.player = new Player();
            updateHealthBar();
            updateHUD();
            
            // Setup audio nodes
            gameState.gainNode = gameState.audioContext.createGain();
            gameState.gainNode.gain.value = gameState.volume;
            
            gameState.analyser = gameState.audioContext.createAnalyser();
            gameState.analyser.fftSize = 256;
            
            gameState.gainNode.connect(gameState.analyser);
            gameState.analyser.connect(gameState.audioContext.destination);
            
            // Create audio source
            gameState.audioSource = gameState.audioContext.createBufferSource();
            gameState.audioSource.buffer = gameState.audioBuffer;
            gameState.audioSource.connect(gameState.gainNode);
            
            // Handle audio end
            gameState.audioSource.onended = () => {
                if (gameState.playing && !gameState.ended) {
                    endGame(true);
                }
            };
            
            // Start playback
            gameState.startTime = Date.now();
            gameState.audioSource.start(0);
            
            // Show mobile controls on touch devices
            if ('ontouchstart' in window) {
                document.getElementById('mobileControls').classList.add('visible');
            }
        }

        function returnToMenu() {
            // Stop audio
            if (gameState.audioSource) {
                try {
                    gameState.audioSource.stop();
                } catch (e) {}
                gameState.audioSource = null;
            }
            
            // Reset UI
            document.getElementById('hud').classList.remove('visible');
            document.getElementById('mobileControls').classList.remove('visible');
            document.getElementById('pauseMenu').classList.remove('visible');
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('mainMenu').removeAttribute('data-difficulty');
            
            // Remove difficulty attribute from body
            document.body.removeAttribute('data-difficulty');
            
            // Reset CONFIG colors to default
            CONFIG.colors = {
                player: '#38bdf8',
                playerDash: '#ffffff',
                obstacle: '#f472b6',
                laserWarning: 'rgba(250, 204, 21, 0.4)',
                laserActive: '#ef4444',
                background: '#0f172a',
                grid: '#1e293b'
            };
            
            // Reset state
            gameState.menu = true;
            gameState.playing = false;
            gameState.paused = false;
            gameState.ended = false;
            gameState.obstacles = [];
            gameState.elapsedTime = 0;
            
            // Reset difficulty selector
            document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.difficulty-btn[data-difficulty="none"]')?.classList.add('active');
            
            // Reset file button
            document.getElementById('audioFile').value = '';
            document.getElementById('fileBtn').textContent = 'Select Song';
            document.getElementById('fileBtn').classList.remove('loaded');
            document.getElementById('songInfo').classList.remove('visible');
            updateStartButtonVisibility();
        }

        // ==================== RENDERING ====================
        let gridOffset = 0;

        function renderBackground() {
            // Clear canvas
            ctx.fillStyle = CONFIG.colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw scrolling grid
            ctx.strokeStyle = CONFIG.colors.grid;
            ctx.lineWidth = 1;
            
            const cellSize = CONFIG.grid.cellSize;
            gridOffset = (gridOffset + CONFIG.grid.scrollSpeed) % cellSize;
            
            // Vertical lines with perspective effect
            for (let x = -gridOffset; x < canvas.width + cellSize; x += cellSize) {
                const perspectiveX = x + (canvas.width - x) * 0.3;
                ctx.beginPath();
                ctx.moveTo(perspectiveX, 0);
                ctx.lineTo(perspectiveX, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = -gridOffset; y < canvas.height + cellSize; y += cellSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // ==================== GAME LOOP ====================
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            
            renderBackground();
            
            if (gameState.playing && !gameState.paused) {
                // Update elapsed time
                gameState.elapsedTime = Date.now() - gameState.startTime;
                
                // Handle input
                handleInput();
                
                // Spawn obstacles
                spawnObstacles();
                
                // Update player
                gameState.player.update();
                
                // Update and check obstacles
                for (let i = gameState.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = gameState.obstacles[i];
                    obstacle.update();
                    
                    if (obstacle.remove) {
                        gameState.obstacles.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision
                    if (obstacle.checkCollision(gameState.player)) {
                        const gameOver = gameState.player.takeDamage();
                        obstacle.remove = true;
                        gameState.obstacles.splice(i, 1);
                        
                        if (gameOver) {
                            endGame(false);
                            break;
                        }
                    }
                }
                
                // Update progress bar
                updateProgressBar();
                
                // Check if song ended
                if (gameState.audioBuffer && gameState.elapsedTime / 1000 >= gameState.audioBuffer.duration) {
                    endGame(true);
                }
            }
            
            // Apply screen shake
            if (shakeIntensity > 0) {
                ctx.save();
                const dx = (Math.random() - 0.5) * shakeIntensity;
                const dy = (Math.random() - 0.5) * shakeIntensity;
                ctx.translate(dx, dy);
                shakeIntensity *= 0.9;
                if (shakeIntensity < 0.5) shakeIntensity = 0;
            }
            
            // Draw obstacles and player (only when not paused)
            if (!gameState.paused) {
                gameState.obstacles.forEach(obs => obs.draw());
                
                if (gameState.player) {
                    gameState.player.draw();
                }
            }
            
            if (shakeIntensity > 0 || (shakeIntensity === 0 && ctx.currentTransform)) {
                ctx.restore();
            }
        }

        // ==================== INITIALIZATION ====================
        function init() {
            setupMenu();
            gameLoop();
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
